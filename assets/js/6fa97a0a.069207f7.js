"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[44082],{55641:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>M,contentTitle:()=>v,default:()=>P,frontMatter:()=>A,metadata:()=>b,toc:()=>w});var t=i(85893),l=i(11151),s=i(74866),o=i(85162);function a(e){const n={code:"code",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example we will generate cell to cell connectivity information between part of  pressure-domain and part of pressure-Domain."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"dim1=2, entity=1"}),"\n",(0,t.jsx)(n.li,{children:"dim2=2, entity=1"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Pressure domain consists Triangle3 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri3",src:i(22534).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: pressureDomain\n  TYPE( HDF5File_ ) :: pressureMeshFile\n  CLASS( Mesh_ ), POINTER :: pressureMesh => NULL()\n  INTEGER( I4B ), POINTER :: cellToCell( : ) => NULL()\n  INTEGER( I4B ) :: ii\n  INTEGER(i4b) :: dim1=2, dim2=2, entity1=1, entity2=1\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create domain for pressure variables, \ud83c\udf87 READ the mesh file, and \u2b55 initiates the domain for pressure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL pressureMeshFile%Initiate( FileName="./mesh_tri3.h5", MODE="READ" )\n  CALL pressureMeshFile%Open()\n  CALL pressureDomain%Initiate( pressureMeshFile, "")\n  CALL pressureMeshFile%Deallocate()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\n    & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2)."}),"\n",(0,t.jsx)(n.p,{children:"Now we can initiate cell-to-cell DATA between the above mentioned meshes."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL obj%InitiateCellToCellData( domain1=pressureDomain, &\n    & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n  CALL Display("Success!!")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  cellToCell => obj%getCellToCellPointer()\n  pressureMesh => pressureDomain%getMeshPointer(dim=dim1, &\n    & entityNum=entity1)\n  DO ii = pressureMesh%minElemNum, pressureMesh%maxElemNum\n    IF (.NOT. pressureMesh%isElementPresent(ii)) CYCLE\n    IF (cellToCell(ii) .NE. ii) THEN\n      CALL FAIL("DomainConnectivity-test has failed")\n      STOP\n    END IF\n  END DO\n  CALL PASS("DomainConnectivity-test-11 has passed")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Cleaning up."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL pressureDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function r(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}function c(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example we will generate cell to cell connectivity information between part of  velocity-domain and part of velocity-Domain."}),"\n",(0,t.jsx)(n.p,{children:"Velocity domain consists Triangle6 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri6",src:i(63148).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: velocityDomain\n  TYPE( HDF5File_ ) :: velocityMeshFile\n  CLASS( Mesh_ ), POINTER :: velocityMesh => NULL()\n  INTEGER( I4B ), POINTER :: cellToCell( : ) => NULL()\n  INTEGER( I4B ) :: ii\n  INTEGER(i4b) :: dim1=2, dim2=2, entity1=1, entity2=1\n"})}),"\n",(0,t.jsx)(n.p,{children:"create domain for velocity variables, \ud83c\udf87 READ the mesh file, and \u2b55 initiates the domain for pressure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL velocityMeshFile%Initiate( FileName="./mesh_tri6.h5", MODE="READ" )\n  CALL velocityMeshFile%Open()\n  CALL velocityDomain%Initiate( velocityMeshFile, "")\n  CALL velocityMeshFile%Deallocate()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\n    & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2)."}),"\n",(0,t.jsx)(n.p,{children:"Now we can initiate cell-to-cell DATA between the above mentioned meshes."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateCellToCellData( domain1=velocityDomain, &\n    & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  cellToCell => obj%getCellToCellPointer()\n  velocityMesh => velocityDomain%getMeshPointer(dim=dim1, &\n    & entityNum=entity1)\n  DO ii = velocityMesh%minElemNum, velocityMesh%maxElemNum\n    IF (.NOT. velocityMesh%isElementPresent(ii)) CYCLE\n    IF (cellToCell(ii) .NE. ii) THEN\n      CALL FAIL("DomainConnectivity-test has failed")\n      STOP\n    END IF\n  END DO\n  CALL PASS("DomainConnectivity-test has passed")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Cleaning up."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL velocityDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function m(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}function d(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example we will generate cell to cell connectivity information between part of  pressure-domain and part of pressure-Domain. We will map boundary of a domain with the boundary of the other domain"}),"\n",(0,t.jsx)(n.p,{children:"Pressure domain consists Triangle3 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri3",src:i(22534).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Velocity domain consists Triangle6 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri6",src:i(63148).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Importing modules and variables"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: pressureDomain\n  TYPE( HDF5File_ ) :: pressureMeshFile\n  CLASS( Mesh_ ), POINTER :: pressureMesh => NULL()\n  INTEGER( I4B ), POINTER :: cellToCell( : ) => NULL()\n  INTEGER( I4B ) :: ii\n  INTEGER(i4b) :: dim1=1, dim2=1, entity1=1, entity2=1\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create domain for pressure variables, \ud83c\udf87 READ the mesh file, and \u2b55 initiates the domain for pressure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL pressureMeshFile%Initiate( FileName="./mesh_tri3.h5", MODE="READ" )\n  CALL pressureMeshFile%Open()\n  CALL pressureDomain%Initiate( pressureMeshFile, "")\n  CALL pressureMeshFile%Deallocate()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\n    & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2)."}),"\n",(0,t.jsx)(n.p,{children:"Now we can initiate cell-to-cell DATA between the above mentioned meshes."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL obj%InitiateCellToCellData( domain1=pressureDomain, &\n    & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n  CALL Display("Success!!")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  cellToCell => obj%getCellToCellPointer()\n  pressureMesh => pressureDomain%getMeshPointer(dim=dim1, &\n    & entityNum=entity1)\n  DO ii = pressureMesh%minElemNum, pressureMesh%maxElemNum\n    IF (.NOT. pressureMesh%isElementPresent(ii)) CYCLE\n    IF (cellToCell(ii) .NE. ii) THEN\n      CALL FAIL("DomainConnectivity-test-11 has failed")\n      STOP\n    END IF\n  END DO\n  CALL PASS("DomainConnectivity-test has passed")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Cleaning up."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL pressureDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}function u(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example we will generate cell to cell connectivity information between part of  velocity-domain and part of velocity-Domain."}),"\n",(0,t.jsx)(n.p,{children:"Pressure domain consists Triangle3 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri3",src:i(22534).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Velocity domain consists Triangle6 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri6",src:i(63148).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Importing modules and variables"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: velocityDomain\n  TYPE( HDF5File_ ) :: velocityMeshFile\n  CLASS( Mesh_ ), POINTER :: velocityMesh => NULL()\n  INTEGER( I4B ), POINTER :: cellToCell( : ) => NULL()\n  INTEGER( I4B ) :: ii\n  INTEGER(i4b) :: dim1=1, dim2=1, entity1=1, entity2=1\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create domain for velocity variables, \ud83c\udf87 READ the mesh file, and \u2b55 initiates the domain for pressure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL velocityMeshFile%Initiate( FileName="./mesh_tri6.h5", MODE="READ" )\n  CALL velocityMeshFile%Open()\n  CALL velocityDomain%Initiate( velocityMeshFile, "")\n  CALL velocityMeshFile%Deallocate()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\n    & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2)."}),"\n",(0,t.jsx)(n.p,{children:"Now we can initiate cell-to-cell DATA between the above mentioned meshes."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateCellToCellData( domain1=velocityDomain, &\n    & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  cellToCell => obj%getCellToCellPointer()\n  velocityMesh => velocityDomain%getMeshPointer(dim=dim1, &\n    & entityNum=entity1)\n  DO ii = velocityMesh%minElemNum, velocityMesh%maxElemNum\n    IF (.NOT. velocityMesh%isElementPresent(ii)) CYCLE\n    IF (cellToCell(ii) .NE. ii) THEN\n      CALL FAIL("DomainConnectivity-test-11 has failed")\n      STOP\n    END IF\n  END DO\n  CALL PASS("DomainConnectivity-test has passed")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Cleaning up."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL velocityDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function p(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}function x(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example we will show how to USE [[DomainConnectivity_#InitiateCellToCell]] method to generate cell-to-cell connectivity information between part of velocity-domain and part of pressure-Domain."}),"\n",(0,t.jsx)(n.p,{children:"Pressure domain consists Triangle3 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri3",src:i(22534).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Velocity domain consists Triangle6 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri6",src:i(63148).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"IMPORT modules and classes"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: pressureDomain\n  TYPE( Domain_ ) :: velocityDomain\n  TYPE( HDF5File_ ) :: pressureMeshFile\n  TYPE( HDF5File_ ) :: velocityMeshFile\n  CLASS( Mesh_ ), POINTER :: velocityMesh\n  CLASS( Mesh_ ), POINTER :: pressureMesh\n  INTEGER( I4B ), POINTER :: cellToCell( : )\n  INTEGER( I4B ) :: ii\n  INTEGER(i4b), PARAMETER :: dim1=2, dim2=2, entity1=1, entity2=1\n"})}),"\n",(0,t.jsx)(n.p,{children:"create domain for velocity variables, \ud83c\udf87 READ the mesh file, and \u2b55 initiates the domain for pressure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL velocityMeshFile%Initiate( FileName="./mesh_tri6.h5", MODE="READ" )\n  CALL velocityMeshFile%Open()\n  CALL velocityDomain%Initiate( velocityMeshFile, "")\n  CALL velocityMeshFile%Deallocate()\n'})}),"\n",(0,t.jsx)(n.p,{children:"create domain for pressure variables, \ud83c\udf87 READ the mesh file, and \u2b55 initiates the domain for pressure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL pressureMeshFile%Initiate( FileName="./mesh_tri3.h5", MODE="READ" )\n  CALL pressureMeshFile%Open()\n  CALL pressureDomain%Initiate( pressureMeshFile, "")\n  CALL pressureMeshFile%Deallocate()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\n    & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2)."}),"\n",(0,t.jsx)(n.p,{children:"Now we can initiate cell-to-cell DATA between the above mentioned meshes."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateCellToCellData( domain1=velocityDomain, &\n    & domain2=pressureDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  cellToCell => obj%getCellToCellPointer()\n  velocityMesh => velocityDomain%getMeshPointer(dim=dim1, &\n    & entityNum=entity1)\n  DO ii = velocityMesh%minElemNum, velocityMesh%maxElemNum\n    IF (.NOT. velocityMesh%isElementPresent(ii)) CYCLE\n    IF (cellToCell(ii) .EQ. 0) THEN\n      CALL FAIL("DomainConnectivity-test has failed")\n      STOP\n    END IF\n  END DO\n  CALL PASS("DomainConnectivity-test has passed")\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL pressureDomain%Deallocate()\n  CALL velocityDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function j(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(x,{...e})}):x(e)}function D(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example, we will show how to USE [[DomainConnectivity_#InitiateCellToCellData]] method to generate cell-to-cell connectivity information between part of velocity-domain and part of pressure-Domain."}),"\n",(0,t.jsx)(n.p,{children:"Pressure domain consists Triangle3 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri3",src:i(22534).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Velocity domain consists Triangle6 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri6",src:i(63148).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: pressureDomain\n  TYPE( Domain_ ) :: velocityDomain\n  TYPE( HDF5File_ ) :: pressureMeshFile\n  TYPE( HDF5File_ ) :: velocityMeshFile\n  CLASS( Mesh_ ), POINTER :: velocityMesh\n  CLASS( Mesh_ ), POINTER :: pressureMesh\n  INTEGER( I4B ), POINTER :: cellToCell( : )\n  INTEGER( I4B ) :: ii\n  INTEGER(i4b), PARAMETER :: dim1=2, dim2=2, entity1=1, entity2=1\n"})}),"\n",(0,t.jsx)(n.p,{children:"Create domain for velocity variables, \ud83c\udf87 READ the mesh file, and \u2b55 initiates the domain for pressure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL velocityMeshFile%Initiate( FileName="./mesh_tri6.h5", MODE="READ" )\n  CALL velocityMeshFile%Open()\n  CALL velocityDomain%Initiate( velocityMeshFile, "")\n  CALL velocityMeshFile%Deallocate()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Create domain for pressure variables, \ud83c\udf87 READ the mesh file, and \u2b55 initiates the domain for pressure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL pressureMeshFile%Initiate( FileName="./mesh_tri3.h5", MODE="READ" )\n  CALL pressureMeshFile%Open()\n  CALL pressureDomain%Initiate( pressureMeshFile, "")\n  CALL pressureMeshFile%Deallocate()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiates the node to node connectivity DATA. It is important that we initiate the node to node DATA before initiating cell to cell DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\n    & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will create node-to-node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2)."}),"\n",(0,t.jsx)(n.p,{children:"Now we can initiate cell-to-cell DATA between the above mentioned meshes."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateCellToCellData( domain1=pressureDomain, &\n    & domain2=velocityDomain, dim1=dim1, entityNum1=entity1, dim2=dim2, &\n    & entityNum2=entity2)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now let us run some checks on the results. This is ONLY for the testing purpose. IF you want, you can skip this part, and move on to the next examples."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  cellToCell => obj%getCellToCellPointer()\n  pressureMesh => pressureDomain%getMeshPointer(dim=dim1, &\n    & entityNum=entity1)\n  DO ii = pressureMesh%minElemNum, pressureMesh%maxElemNum\n    IF (.NOT. pressureMesh%isElementPresent(ii)) CYCLE\n    IF (cellToCell(ii) .EQ. 0) THEN\n      CALL FAIL("DomainConnectivity-test has failed")\n      STOP\n    END IF\n  END DO\n  CALL PASS("DomainConnectivity-test has passed")\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL pressureDomain%Deallocate()\n  CALL velocityDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function N(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(D,{...e})}):D(e)}function E(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example we will generate cell to cell connectivity information between pressure-domain and pressure-Domain."}),"\n",(0,t.jsx)(n.p,{children:"Pressure domain consists Triangle3 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri3",src:i(22534).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Velocity domain consists Triangle6 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri6",src:i(63148).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Importing modules and variables"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: pressureDomain\n  TYPE( HDF5File_ ) :: pressureMeshFile\n  CLASS( Mesh_ ), POINTER :: pressureMesh\n  CLASS( ReferenceElement_ ), POINTER :: refelem\n  INTEGER( I4B ), POINTER :: cellToCell( : )\n  INTEGER( I4B ) :: ii, iel\n  INTEGER(I4B), PARAMETER :: dim1=2, dim2=2, entity1=1, entity2=1\n"})}),"\n",(0,t.jsx)(n.p,{children:"Initiate domain for pressure variable."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL pressureMeshFile%Initiate( FileName="./mesh_tri3.h5", MODE="READ" )\n  CALL pressureMeshFile%Open()\n  CALL pressureDomain%Initiate( pressureMeshFile, "")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiate node to node DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\n    & domain2=pressureDomain )\n  CALL PASS("InitiateNodeToNodeData()")\n'})}),"\n",(0,t.jsx)(n.p,{children:"This will create node to node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2)."}),"\n",(0,t.jsx)(n.p,{children:"Initiate cell to cell connectivity DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateCellToCellData(domain1=pressureDomain, &\n    & domain2=pressureDomain)\n"})}),"\n",(0,t.jsx)(n.p,{children:"now let us run some tests."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'    cellToCell => obj%getCellToCellPointer()\n    DO iel = pressureDomain%minElemNum, pressureDomain%maxElemNum\n      IF (.NOT. pressureDomain%isElementPresent(iel)) CYCLE\n      IF (cellToCell(iel) .EQ. 0) THEN\n        pressureMesh => pressureDomain%getMeshPointer(globalElement=iel)\n        refelem => pressureMesh%getRefElemPointer()\n        IF (refelem%xidimension .EQ. pressureDomain%getNSD()) &\n          & CALL fail("CellToCell: error code 1")\n      ELSE\n        IF (cellToCell(iel) .NE. iel) THEN\n          CALL fail("CellToCell: error code 2")\n          STOP\n        END IF\n      END IF\n    END DO\n    CALL PASS("InitiateCellToCellData()")\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL pressureMeshFile%Deallocate()\n  CALL pressureDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function C(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(E,{...e})}):E(e)}function T(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example we will generate cell to cell connectivity information between velocity-domain and velocity-Domain."}),"\n",(0,t.jsx)(n.p,{children:"Pressure domain consists Triangle3 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri3",src:i(22534).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Velocity domain consists Triangle6 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri6",src:i(63148).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Importing modules and variables"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: velocityDomain\n  TYPE( HDF5File_ ) :: velocityMeshFile\n  CLASS( Mesh_ ), POINTER :: velocityMesh\n  CLASS( ReferenceElement_ ), POINTER :: refelem\n  INTEGER( I4B ), POINTER :: cellToCell( : )\n  INTEGER( I4B ) :: ii, iel\n  INTEGER(I4B), PARAMETER :: dim1=2, dim2=2, entity1=1, entity2=1\n"})}),"\n",(0,t.jsx)(n.p,{children:"Initiate domain for velocity variable."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL velocityMeshFile%Initiate( FileName="./mesh_tri6.h5", MODE="READ" )\n  CALL velocityMeshFile%Open()\n  CALL velocityDomain%Initiate( velocityMeshFile, "")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiate node to node DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\n    & domain2=velocityDomain )\n  CALL PASS("InitiateNodeToNodeData()")\n'})}),"\n",(0,t.jsx)(n.p,{children:"This will create node to node connectivity DATA from domain1 (dim=2, entityNum=1) to domain2 (dim=2, entityNum=2)."}),"\n",(0,t.jsx)(n.p,{children:"Initiate cell to cell connectivity DATA."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateCellToCellData(domain1=velocityDomain, &\n    & domain2=velocityDomain)\n"})}),"\n",(0,t.jsx)(n.p,{children:"now let us run some tests, this  is only for testing purpose, so you can ignore the forthcoming section."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'    cellToCell => obj%getCellToCellPointer()\n    DO iel = velocityDomain%minElemNum, velocityDomain%maxElemNum\n      IF (.NOT. velocityDomain%isElementPresent(iel)) CYCLE\n      IF (cellToCell(iel) .EQ. 0) THEN\n        velocityMesh => velocityDomain%getMeshPointer(globalElement=iel)\n        refelem => velocityMesh%getRefElemPointer()\n        IF (refelem%xidimension .EQ. velocityDomain%getNSD()) &\n          & CALL fail("CellToCell: error code 1")\n      ELSE\n        IF (cellToCell(iel) .NE. iel) THEN\n          CALL fail("CellToCell: error code 2")\n          STOP\n        END IF\n      END IF\n    END DO\n    CALL PASS("InitiateCellToCellData()")\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL velocityMeshFile%Deallocate()\n  CALL velocityDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function y(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(T,{...e})}):T(e)}function f(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example we will generate cell to cell connectivity information between velocity-domain and pressure-Domain."}),"\n",(0,t.jsx)(n.p,{children:"Pressure domain consists Triangle3 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri3",src:i(22534).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Velocity domain consists Triangle6 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri6",src:i(63148).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Importing modules and variables"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: pressureDomain\n  TYPE( Domain_ ) :: velocityDomain\n  TYPE( HDF5File_ ) :: pressureMeshFile\n  TYPE( HDF5File_ ) :: velocityMeshFile\n  CLASS( Mesh_ ), POINTER :: velocityMesh\n  CLASS( Mesh_ ), POINTER :: pressureMesh\n  CLASS( ReferenceElement_ ), POINTER :: velocityRefelem\n  CLASS( ReferenceElement_ ), POINTER :: pressureRefelem\n  CLASS( ReferenceElement_ ), POINTER :: refelem\n  INTEGER( I4B ), POINTER :: cellToCell( : )\n  INTEGER( I4B ) :: ii, iel\n"})}),"\n",(0,t.jsx)(n.p,{children:"Open the mesh file for pressure and velocity domain"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL velocityMeshFile%Initiate( FileName="./mesh_tri6.h5", MODE="READ" )\n  CALL velocityMeshFile%Open()\n  CALL pressureMeshFile%Initiate( FileName="./mesh_tri3.h5", MODE="READ" )\n  CALL pressureMeshFile%Open()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiate the domain for pressure and velocity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL velocityDomain%Initiate( velocityMeshFile, "")\n  CALL pressureDomain%Initiate( pressureMeshFile, "")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiate node to node data between velocity domain and pressure domain."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL obj%InitiateNodeToNodeData( domain1=velocityDomain, &\n    & domain2=pressureDomain )\n  CALL PASS("InitiateNodeToNodeData()")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now that node-to-node data is ready, let us initiate cell to cell data from velocity domain to pressure domain."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateCellToCellData( domain1=velocityDomain, &\n    & domain2=pressureDomain )\n"})}),"\n",(0,t.jsx)(n.p,{children:"now let us run some tests to check the validity of the data. This is only for testing purpose, so you can ignore the forthcoming section."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'    cellToCell => obj%getCellToCellPointer()\n    DO iel = velocityDomain%minElemNum, velocityDomain%maxElemNum\n      IF (.NOT. velocityDomain%isElementPresent(iel)) CYCLE\n      IF (cellToCell(iel) .EQ. 0) THEN\n        velocityMesh => velocityDomain%getMeshPointer(globalElement=iel)\n        refelem => velocityMesh%getRefElemPointer()\n        IF (refelem%xidimension .EQ. velocityDomain%getNSD()) THEN\n          CALL fail("CellToCell: error code 1")\n          STOP\n        END IF\n      ELSE\n        !! here i am checking if the cellToCell(iel) is present in\n        !! in the pressure domain or not.\n        !! If it is present then it should be a cell element.\n        ii = cellToCell(iel)\n        IF (.NOT. pressureDomain%isElementPresent(ii)) THEN\n          CALL fail("CellToCell: error code 2")\n          STOP\n        ELSE\n          velocityMesh => velocityDomain%getMeshPointer(globalElement=iel)\n          velocityRefelem => velocityMesh%getRefElemPointer()\n          pressureMesh => pressureDomain%getMeshPointer(globalElement=ii)\n          pressureRefelem => pressureMesh%getRefElemPointer()\n          IF (pressureRefelem%xidimension .NE. velocityRefelem%xidimension) THEN\n            CALL fail("CellToCell: error code 3")\n            STOP\n          END IF\n        END IF\n      END IF\n    END DO\n    CALL PASS("InitiateCellToCellData()")\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL pressureMeshFile%Deallocate()\n  CALL velocityMeshFile%Deallocate()\n  CALL pressureDomain%Deallocate()\n  CALL velocityDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function g(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(f,{...e})}):f(e)}function L(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In this example we will generate cell to cell connectivity information between pressure-domain and velocity-Domain."}),"\n",(0,t.jsx)(n.p,{children:"Pressure domain consists Triangle3 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri3",src:i(22534).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Velocity domain consists Triangle6 elements as shown below."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"mesh_tri6",src:i(63148).Z+"",width:"916",height:"955"})}),"\n",(0,t.jsx)(n.p,{children:"Importing modules and variables"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"PROGRAM main\n  USE easifemBase\n  USE easifemClasses\n  IMPLICIT NONE\n  TYPE(DomainConnectivity_) :: obj\n  TYPE( Domain_ ) :: pressureDomain\n  TYPE( Domain_ ) :: velocityDomain\n  TYPE( HDF5File_ ) :: pressureMeshFile\n  TYPE( HDF5File_ ) :: velocityMeshFile\n  CLASS( Mesh_ ), POINTER :: velocityMesh\n  CLASS( Mesh_ ), POINTER :: pressureMesh\n  CLASS( ReferenceElement_ ), POINTER :: refelem\n  CLASS( ReferenceElement_ ), POINTER :: velocityRefelem\n  CLASS( ReferenceElement_ ), POINTER :: pressureRefelem\n  INTEGER( I4B ), POINTER :: cellToCell( : )\n  INTEGER( I4B ) :: ii, iel\n"})}),"\n",(0,t.jsx)(n.p,{children:"Open the mesh file for pressure and velocity domain"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL velocityMeshFile%Initiate( FileName="./mesh_tri6.h5", MODE="READ" )\n  CALL velocityMeshFile%Open()\n  CALL pressureMeshFile%Initiate( FileName="./mesh_tri3.h5", MODE="READ" )\n  CALL pressureMeshFile%Open()\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiate the domain for pressure and velocity"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL velocityDomain%Initiate( velocityMeshFile, "")\n  CALL pressureDomain%Initiate( pressureMeshFile, "")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Initiate node to node data between velocity domain and pressure domain."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'  CALL obj%InitiateNodeToNodeData( domain1=pressureDomain, &\n    & domain2=velocityDomain )\n  CALL PASS("InitiateNodeToNodeData()")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now that node-to-node data is ready, let us initiate cell to cell data from pressure domain to velocity domain."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL obj%InitiateCellToCellData( domain1=pressureDomain, &\n    & domain2=velocityDomain )\n"})}),"\n",(0,t.jsx)(n.p,{children:"now let us run some tests to check the validity of the data. This is only for testing purpose, so you can ignore the forthcoming section."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:'    cellToCell => obj%getCellToCellPointer()\n    DO iel = pressureDomain%minElemNum, pressureDomain%maxElemNum\n      IF (.NOT. pressureDomain%isElementPresent(iel)) CYCLE\n      IF (cellToCell(iel) .EQ. 0) THEN\n        pressureMesh => pressureDomain%getMeshPointer(globalElement=iel)\n        refelem => pressureMesh%getRefElemPointer()\n        IF (refelem%xidimension .EQ. pressureDomain%getNSD()) THEN\n          CALL fail("CellToCell: error code 1")\n          STOP\n        END IF\n      ELSE\n        !! here i am checking if the cellToCell(iel) is present in\n        !! in the pressure domain or not.\n        !! If it is present then it should be a cell element.\n        ii = cellToCell(iel)\n        IF (.NOT. velocityDomain%isElementPresent(ii)) THEN\n          CALL fail("CellToCell: error code 2")\n          STOP\n        ELSE\n          velocityMesh => velocityDomain%getMeshPointer(globalElement=ii)\n          velocityRefelem => velocityMesh%getRefElemPointer()\n          pressureMesh => pressureDomain%getMeshPointer(globalElement=iel)\n          pressureRefelem => pressureMesh%getRefElemPointer()\n          IF (pressureRefelem%xidimension .NE. velocityRefelem%xidimension) THEN\n            CALL fail("CellToCell: error code 3")\n            STOP\n          END IF\n        END IF\n      END IF\n    END DO\n    CALL PASS("InitiateCellToCellData()")\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"  CALL pressureMeshFile%Deallocate()\n  CALL velocityMeshFile%Deallocate()\n  CALL pressureDomain%Deallocate()\n  CALL velocityDomain%Deallocate()\n  CALL obj%Deallocate()\nEND PROGRAM main\n"})})]})}function I(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(L,{...e})}):L(e)}const A={},v="InitiateCellToCellData",b={id:"DomainConnectivity/InitiateCellToCellData",title:"InitiateCellToCellData",description:"This routine initiates cellToCell data (mapping) between two Domain or Mesh.",source:"@site/docs/docs-api/DomainConnectivity/InitiateCellToCellData.md",sourceDirName:"DomainConnectivity",slug:"/DomainConnectivity/InitiateCellToCellData",permalink:"/docs-api/DomainConnectivity/InitiateCellToCellData",draft:!1,unlisted:!1,editUrl:"https://github.com/easifem-fortran/easifem-fortran.github.io/tree/main/docs/docs-api/DomainConnectivity/InitiateCellToCellData.md",tags:[],version:"current",lastUpdatedAt:1701057211,formattedLastUpdatedAt:"Nov 27, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"GlobalFacetID",permalink:"/docs-api/DomainConnectivity/GlobalFacetID"},next:{title:"InitiateFacetToCellData",permalink:"/docs-api/DomainConnectivity/InitiateFacetToCellData"}},M={},w=[{value:"Interface1",id:"interface1",level:2},{value:"Interface2",id:"interface2",level:2}];function F(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"initiatecelltocelldata",children:"InitiateCellToCellData"}),"\n",(0,t.jsxs)(n.p,{children:["This routine initiates cellToCell data (mapping) between two ",(0,t.jsx)(n.a,{href:"/docs-api/Domain/Domain_",children:"Domain_"})," or ",(0,t.jsx)(n.a,{href:"/docs-api/Mesh/Mesh_",children:"Mesh_"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The topology of elements in both meshes should be the same, this means that if one mesh is made of triangles then other mesh should be made of triangles."}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"xidim"})," of the elements in both meshes should be the same, this means that if the ",(0,t.jsx)(n.code,{children:"mesh1"})," is surface mesh then ",(0,t.jsx)(n.code,{children:"mesh2"})," should be a surface mesh."]}),"\n",(0,t.jsxs)(n.li,{children:["This routine needs ",(0,t.jsx)(n.code,{children:"nodeToNode"})," information, so make sure it is initiated before calling this routine."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"interface1",children:"Interface1"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE dc_initiateCellToCellData1(obj, domain1, domain2, &\n    & dim1, dim2, entityNum1, entityNum2)\n    CLASS(DomainConnectivity_), INTENT(INOUT) :: obj\n    !! Domain connectivity object,\n    !! [[DomainConnectivity:cellToCell]] will be initiated\n    CLASS(Domain_), INTENT(IN) :: domain1\n    !! Primary domain, in cellToCell(i), i denotes the\n    !! global element number in domain1 domain.\n    CLASS(Domain_), INTENT(IN) :: domain2\n    !! secondary domain, => cellToCell(i) denotes the\n    !! global cell number in `domain2` domain.\n    INTEGER(I4B), INTENT(IN) :: dim1\n    !! dimension of mesh in domain1\n    INTEGER(I4B), INTENT(IN) :: dim2\n    !! dimension of mesh in domain2\n    INTEGER(I4B), INTENT(IN) :: entityNum1\n    !! entity num of mesh in domain1\n    INTEGER(I4B), INTENT(IN) :: entityNum2\n    !! entity num of mesh in domain2\n  END SUBROUTINE dc_initiateCellToCellData1\nEND INTERFACE\n"})}),"\n",(0,t.jsx)(n.p,{children:"This subroutine generates the cell to cell connectivity between two meshes."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"obj%cellToCell"})," will be initiated"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"domain1"})," main domain"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"domain2"})," secondary domain"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dim1, entitynum1"})," dimension and entity number of mesh in ",(0,t.jsx)(n.code,{children:"domain1"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dim2, entitynum2"})," dimension and entity number of mesh in ",(0,t.jsx)(n.code,{children:"domain2"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Following points should be noted"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The topology of elements in both meshes should be the same, this means that if one mesh is triangle then other mesh should be a triangle."}),"\n",(0,t.jsx)(n.li,{children:"The xidim of the elements in both meshes should be the same, this means that if the mesh1 is surface mesh then mesh2 should be a surface mesh."}),"\n",(0,t.jsxs)(n.li,{children:["This routine needs ",(0,t.jsx)(n.code,{children:"nodeToNode"})," information, so make sure it is initiated before calling this routine."]}),"\n"]}),"\n","\n","\n",(0,t.jsxs)(s.Z,{children:[(0,t.jsx)(o.Z,{value:"1",label:"\ufe0f\u0700 Example 1",children:(0,t.jsx)(r,{})}),(0,t.jsx)(o.Z,{value:"2",label:"\ufe0f\u0700 Example 2",children:(0,t.jsx)(m,{})}),(0,t.jsx)(o.Z,{value:"3",label:"\ufe0f\u0700 Example 3",children:(0,t.jsx)(h,{})}),(0,t.jsx)(o.Z,{value:"4",label:"\ufe0f\u0700 Example 4",children:(0,t.jsx)(p,{})}),(0,t.jsx)(o.Z,{value:"5",label:"\ufe0f\u0700 Example 5",children:(0,t.jsx)(j,{})}),(0,t.jsx)(o.Z,{value:"close",label:"\u21a2",default:!0})]}),"\n",(0,t.jsxs)(s.Z,{children:[(0,t.jsx)(o.Z,{value:"6",label:"\ufe0f\u0700 Example 6",children:(0,t.jsx)(N,{})}),(0,t.jsx)(o.Z,{value:"7",label:"\ufe0f\u0700 Example 7",children:(0,t.jsx)(C,{})}),(0,t.jsx)(o.Z,{value:"8",label:"\ufe0f\u0700 Example 8",children:(0,t.jsx)(y,{})}),(0,t.jsx)(o.Z,{value:"close",label:"\u21a2",default:!0})]}),"\n",(0,t.jsx)(n.h2,{id:"interface2",children:"Interface2"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"INTERFACE\n  MODULE SUBROUTINE dc_InitiateCellToCellData2(obj, domain1, domain2)\n    CLASS(DomainConnectivity_), INTENT(INOUT) :: obj\n    !! Domain connectivity object\n    CLASS(Domain_), INTENT(IN) :: domain1\n    !! Primary domain, in CellToCell(i), i denotes the\n    !! global element number in domain1 domain.\n    CLASS(Domain_), INTENT(IN) :: domain2\n    !! Secondary domain => CellToCell(i) denotes the\n    !! global element number in domain2 domain.\n  END SUBROUTINE dc_InitiateCellToCellData2\nEND INTERFACE\n"})}),"\n",(0,t.jsx)(n.p,{children:"This subroutine generates the cell to cell connectivity between\ntwo domains."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"obj%cellToCell"})," will be initiated"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"domain1"})," main domain"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"domain2"})," secondary domain"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["All ",(0,t.jsx)(n.strong,{children:"CELL"})," elements in domain-1 will be mapped to ",(0,t.jsx)(n.strong,{children:"CELL"})," elements in domain-2."]})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"cellToCell(iel)"})," is equal to zero then it means there is no element found in domain-2 corresponding to element number iel in domain-1."]})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The size of ",(0,t.jsx)(n.code,{children:"cellToCell"})," is the largest element number present in domain1."]})}),"\n",(0,t.jsx)(n.admonition,{title:"TODO",type:"info",children:(0,t.jsx)(n.p,{children:"Currently, lowerbound and upper bound of cellToCell is 1 and domain1%maxElemNumber. In the future, the lower bound will be domain1%minElemNumber."})}),"\n",(0,t.jsx)(n.p,{children:"Following points should be noted before calling this routine"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"This routine provides map between cell elements of one domain to cell elements of another domain."}),"\n",(0,t.jsx)(n.li,{children:"The topology of the both elements should be the same"}),"\n",(0,t.jsx)(n.li,{children:"There is one to one mapping between elements of domain 1 and elements of domain2"}),"\n",(0,t.jsx)(n.li,{children:"This routine works well for two domains of same region with same/different order. For example, domain of tri3 and domain of tri6 elements."}),"\n"]}),"\n",(0,t.jsxs)(s.Z,{children:[(0,t.jsx)(o.Z,{value:"1",label:"\ufe0f\u0700 Example 1",children:(0,t.jsx)(g,{})}),(0,t.jsx)(o.Z,{value:"2",label:"\ufe0f\u0700 Example 2",children:(0,t.jsx)(I,{})}),(0,t.jsx)(o.Z,{value:"close",label:"\u21a2",default:!0})]})]})}function P(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(F,{...e})}):F(e)}},85162:(e,n,i)=>{i.d(n,{Z:()=>o});i(67294);var t=i(86010);const l={tabItem:"tabItem_Ymn6"};var s=i(85893);function o(e){let{children:n,hidden:i,className:o}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,t.Z)(l.tabItem,o),hidden:i,children:n})}},74866:(e,n,i)=>{i.d(n,{Z:()=>y});var t=i(67294),l=i(86010),s=i(12466),o=i(16550),a=i(20469),r=i(91980),c=i(67392),m=i(50012);function d(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:i}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:i,attributes:t,default:l}}=e;return{value:n,label:i,attributes:t,default:l}}))}(i);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function u(e){let{value:n,tabValues:i}=e;return i.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:i}=e;const l=(0,o.k6)(),s=function(e){let{queryString:n=!1,groupId:i}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:n,groupId:i});return[(0,r._X)(s),(0,t.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(l.location.search);n.set(s,e),l.replace({...l.location,search:n.toString()})}),[s,l])]}function x(e){const{defaultValue:n,queryString:i=!1,groupId:l}=e,s=h(e),[o,r]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!u({value:n,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=i.find((e=>e.default))??i[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:s}))),[c,d]=p({queryString:i,groupId:l}),[x,j]=function(e){let{groupId:n}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(n),[l,s]=(0,m.Nk)(i);return[l,(0,t.useCallback)((e=>{i&&s.set(e)}),[i,s])]}({groupId:l}),D=(()=>{const e=c??x;return u({value:e,tabValues:s})?e:null})();(0,a.Z)((()=>{D&&r(D)}),[D]);return{selectedValue:o,selectValue:(0,t.useCallback)((e=>{if(!u({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);r(e),d(e),j(e)}),[d,j,s]),tabValues:s}}var j=i(72389);const D={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var N=i(85893);function E(e){let{className:n,block:i,selectedValue:t,selectValue:o,tabValues:a}=e;const r=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.o5)(),m=e=>{const n=e.currentTarget,i=r.indexOf(n),l=a[i].value;l!==t&&(c(n),o(l))},d=e=>{let n=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const i=r.indexOf(e.currentTarget)+1;n=r[i]??r[0];break}case"ArrowLeft":{const i=r.indexOf(e.currentTarget)-1;n=r[i]??r[r.length-1];break}}n?.focus()};return(0,N.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":i},n),children:a.map((e=>{let{value:n,label:i,attributes:s}=e;return(0,N.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>r.push(e),onKeyDown:d,onClick:m,...s,className:(0,l.Z)("tabs__item",D.tabItem,s?.className,{"tabs__item--active":t===n}),children:i??n},n)}))})}function C(e){let{lazy:n,children:i,selectedValue:l}=e;const s=(Array.isArray(i)?i:[i]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===l));return e?(0,t.cloneElement)(e,{className:"margin-top--md"}):null}return(0,N.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==l})))})}function T(e){const n=x(e);return(0,N.jsxs)("div",{className:(0,l.Z)("tabs-container",D.tabList),children:[(0,N.jsx)(E,{...e,...n}),(0,N.jsx)(C,{...e,...n})]})}function y(e){const n=(0,j.Z)();return(0,N.jsx)(T,{...e,children:d(e.children)},String(n))}},22534:(e,n,i)=>{i.d(n,{Z:()=>t});const t=i.p+"assets/images/mesh_tri3-f040e740b2563c42265e62d3b8a5d5cf.png"},63148:(e,n,i)=>{i.d(n,{Z:()=>t});const t=i.p+"assets/images/mesh_tri6-48a06b485c95049e2ae16c0c60c896c4.png"},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>o});var t=i(67294);const l={},s=t.createContext(l);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);