"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[86128],{88348:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>h,contentTitle:()=>c,default:()=>a,frontMatter:()=>o,metadata:()=>l,toc:()=>r});var n=t(85893),i=t(11151);const o={},c="Structure",l={id:"MeshSelection/MeshSelection_",title:"Structure",description:"MeshSelection class is designed to select parts of domain object.",source:"@site/docs/docs-api/MeshSelection/MeshSelection_.md",sourceDirName:"MeshSelection",slug:"/MeshSelection/MeshSelection_",permalink:"/docs-api/MeshSelection/MeshSelection_",draft:!1,unlisted:!1,editUrl:"https://github.com/easifem-fortran/easifem-fortran.github.io/tree/main/docs/docs-api/MeshSelection/MeshSelection_.md",tags:[],version:"current",lastUpdatedAt:1701057211,formattedLastUpdatedAt:"Nov 27, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"IsNodeNumAllocated",permalink:"/docs-api/MeshSelection/IsNodeNumAllocated"},next:{title:"Set",permalink:"/docs-api/MeshSelection/Set"}},h={},r=[];function d(e){const s={code:"code",h1:"h1",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"structure",children:"Structure"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"MeshSelection_"})," class is designed to select parts of ",(0,n.jsx)(s.code,{children:"domain_"})," object."]}),"\n",(0,n.jsxs)(s.p,{children:["It selects the ",(0,n.jsx)(s.code,{children:"mesh_"})," by using ",(0,n.jsx)(s.code,{children:"meshID"})," , ",(0,n.jsx)(s.code,{children:"elemNum"}),", ",(0,n.jsx)(s.code,{children:"nodeNum"})," and/or ",(0,n.jsx)(s.code,{children:"boundingBox"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"This class can be used to map material properties to meshes. In general it can be used to tag mesh entities."}),"\n",(0,n.jsx)(s.p,{children:"![[MeshSelection_workflow.svg]]"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-fortran",children:"TYPE :: MeshSelection_\n  PRIVATE\n  LOGICAL(LGT), PUBLIC :: isInitiated = .FALSE.\n  LOGICAL(LGT), PUBLIC :: isSelectionByMeshID = .FALSE.\n  LOGICAL(LGT), PUBLIC :: isSelectionByElemNum = .FALSE.\n  LOGICAL(LGT), PUBLIC :: isSelectionByBox = .FALSE.\n  LOGICAL(LGT), PUBLIC :: isSelectionByNodeNum = .FALSE.\n  TYPE(IntVector_) :: pointMeshID\n  TYPE(IntVector_) :: curveMeshID\n  TYPE(IntVector_) :: surfaceMeshID\n  TYPE(IntVector_) :: volumeMeshID\n  TYPE(IntVector_) :: pointElemNum\n  TYPE(IntVector_) :: curveElemNum\n  TYPE(IntVector_) :: surfaceElemNum\n  TYPE(IntVector_) :: volumeElemNum\n  TYPE(IntVector_) :: nodeNum\n"})}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"isInitiated"}),", True if an instance of MeshSelection is initiated"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"isSelectionByMeshID"}),", True if the mesh selection is done by specifying the mesh id"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"isSelectionByElemNum"}),", True if the mesh slection is done by specifying the global element number"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"isSelectionByBox"}),", True if the mesh selection is done by specifying the bounding box"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"isSelectionByNodeNum"}),", True if the mesh selection is done by specifying global node numbers"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"pointMeshID"}),", It denotes the IDs of mesh which has xidim=0, that is point mesh"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"curveMeshID"}),", It denotes the IDs of mesh which has xidim=1, that is, curve mesh"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"surfaceMeshID"}),", It denotes the IDs of mesh which has xidim=2, that is, surface mesh"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"volumeMeshID"}),", It denotes the IDs of mesh which has xidim=3, that is, volume mesh"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"pointElemNum"}),", It denotes the global element numbers that are used to select the mesh, and belongs to the point mesh"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"curveElemNum"}),", It denotes the global element numbers that are used to select the mesh, and belongs to the curve mesh"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"surfaceElemNum"}),", It denotes the global element numbers that are used to select the mesh, and belongs to the surface mesh"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"volumeElemNum"}),", It denotes the global element numbers that are used to select the mesh, and belongs to the volume mesh"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"nodeNum"}),", It denotes the global node number that are used to select the mesh"]}),"\n"]})]})}function a(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},11151:(e,s,t)=>{t.d(s,{Z:()=>l,a:()=>c});var n=t(67294);const i={},o=n.createContext(i);function c(e){const s=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);