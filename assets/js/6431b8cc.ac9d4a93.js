"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[95104],{62418:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>o,toc:()=>a});var t=s(85893),i=s(11151);const d={sidebar_position:2},c="Structure",o={id:"AbstractMeshField/AbstractMeshField_",title:"Structure",description:"varType specify how a value changes inside an element. The value can be constant, space-dependent, time-dependent, or space-time dependent.",source:"@site/docs/docs-api/AbstractMeshField/AbstractMeshField_.md",sourceDirName:"AbstractMeshField",slug:"/AbstractMeshField/AbstractMeshField_",permalink:"/docs-api/AbstractMeshField/AbstractMeshField_",draft:!1,unlisted:!1,editUrl:"https://github.com/easifem-fortran/easifem-fortran.github.io/tree/main/docs/docs-api/AbstractMeshField/AbstractMeshField_.md",tags:[],version:"current",lastUpdatedAt:1702011327,formattedLastUpdatedAt:"Dec 8, 2023",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"AbstractMeshField",permalink:"/docs-api/AbstractMeshField/"},next:{title:"SetAbstractMeshFieldParam",permalink:"/docs-api/AbstractMeshField/SetAbstractMeshFieldParam"}},r={},a=[];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"structure",children:"Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"TYPE, ABSTRACT :: AbstractMeshField_\n  LOGICAL(LGT) :: isInitiated = .FALSE.\n  !! It is true if the object is initiated\n  INTEGER(I4B) :: fieldType = FIELD_TYPE_NORMAL\n  !! fieldType can be normal, constant, can vary in space and/ or both.\n  TYPE(String) :: name\n  !! name of the field\n  TYPE(String) :: engine\n  !! Engine of the field, for example\n  !! NATIVE_SERIAL,\n  !! NATIVE_OMP,\n  !! NATIVE_MPI,\n  !! PETSC,\n  !! LIS_SERIAL,\n  !! LIS_OMP,\n  !! LIS_MPI\n  INTEGER(I4B) :: tSize = 0\n  !! total number of elements\n  INTEGER(I4B) :: defineOn = 0\n  !! Nodal: nodal values\n  !! Quadrature: quadrature values\n  INTEGER(I4B) :: rank = 0\n  !! Scalar\n  !! Vector\n  !! Matrix\n  INTEGER(I4B) :: varType = 0\n  !! Space\n  !! Time\n  !! SpaceTime\n  !! Constant\n  INTEGER(I4B) :: s(MAX_RANK_FEVARIABLE) = 1\n  !! shape of the data\n  REAL(DFP), ALLOCATABLE :: val(:, :)\n  !! values, val( :, iel ) corresponds to element number iel\n  !! iel is local element number\n  !! also, note that val( :, iel ) will be decoded\n  !! based on the information stored in s(:)\n  TYPE(Mesh_), POINTER :: mesh => NULL()\n  !! Domain contains the information of the finite element meshes.\nEND TYPE AbstractMeshField_\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"varType"})}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"varType"})," specify how a value changes inside an element. The value can be constant, space-dependent, time-dependent, or space-time dependent."]})]}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{children:(0,t.jsx)(n.code,{children:"s"})}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"s"})," denotes the shape of data inside an element. The following rule is defined."]}),(0,t.jsx)(n.p,{children:"For a scalar field following rules are defined."}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"varType=Constant"}),", ",(0,t.jsx)(n.code,{children:"s"})," has length 1."]}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"varType=Space | Time"}),", ",(0,t.jsx)(n.code,{children:"s"})," has length 1, which denotes the value at ",(0,t.jsx)(n.code,{children:"Space"})," or ",(0,t.jsx)(n.code,{children:"Time"})," nodes."]}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"varType=SpaceTime"}),", ",(0,t.jsx)(n.code,{children:"s"})," has length 2, which denotes the value at ",(0,t.jsx)(n.code,{children:"Space"})," and ",(0,t.jsx)(n.code,{children:"Time"})," nodes."]}),"\n"]}),(0,t.jsx)(n.p,{children:"For a vector field following rules are defined."}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"varType=Constant"}),", ",(0,t.jsx)(n.code,{children:"s"})," has length 1 which denotes all vector components."]}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"varType=Space | Time"}),", ",(0,t.jsx)(n.code,{children:"s"})," has length 2, which denotes vector components at ",(0,t.jsx)(n.code,{children:"Space"})," or ",(0,t.jsx)(n.code,{children:"Time"})," nodes inside the element."]}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"varType=SpaceTime"}),", ",(0,t.jsx)(n.code,{children:"s"})," has length 3, which denotes vector components at ",(0,t.jsx)(n.code,{children:"Space"})," and ",(0,t.jsx)(n.code,{children:"Time"})," nodes inside the element."]}),"\n"]}),(0,t.jsx)(n.p,{children:"For a tensor field following rules are defined."}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"varType=Constant"}),", ",(0,t.jsx)(n.code,{children:"s"})," has length 2 which denotes tensor components."]}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"varType=Space | Time"}),", ",(0,t.jsx)(n.code,{children:"s"})," has length 3 which denotes tensor components at ",(0,t.jsx)(n.code,{children:"Space"})," or ",(0,t.jsx)(n.code,{children:"Time"})," nodes inside the element."]}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.code,{children:"varType=SpaceTime"}),", ",(0,t.jsx)(n.code,{children:"s"})," has length 4 which denotes tensor components at ",(0,t.jsx)(n.code,{children:"Space"})," and ",(0,t.jsx)(n.code,{children:"Time"})," nodes inside the element."]}),"\n"]})]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>c});var t=s(67294);const i={},d=t.createContext(i);function c(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);