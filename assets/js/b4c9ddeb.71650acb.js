"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[97115],{85495:(N,I,T)=>{T.r(I),T.d(I,{assets:()=>a,contentTitle:()=>t,default:()=>d,frontMatter:()=>e,metadata:()=>o,toc:()=>i});var n=T(85893),E=T(11151);const e={},t="Set",o={id:"AbstractMatrixField/Set",title:"Set",description:"Set the entries in Matrix Field.",source:"@site/docs/docs-api/AbstractMatrixField/Set.md",sourceDirName:"AbstractMatrixField",slug:"/AbstractMatrixField/Set",permalink:"/docs-api/AbstractMatrixField/Set",draft:!1,unlisted:!1,editUrl:"https://github.com/easifem-fortran/easifem-fortran.github.io/tree/main/docs/docs-api/AbstractMatrixField/Set.md",tags:[],version:"current",lastUpdatedAt:1701057211,formattedLastUpdatedAt:"Nov 27, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ReversePermutation",permalink:"/docs-api/AbstractMatrixField/ReversePermutation"},next:{title:"SetColumn",permalink:"/docs-api/AbstractMatrixField/SetColumn"}},a={},i=[{value:"Interface",id:"interface",level:2}];function r(N){const I={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,E.a)(),...N.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(I.h1,{id:"set",children:"Set"}),"\n",(0,n.jsx)(I.p,{children:"Set the entries in Matrix Field."}),"\n",(0,n.jsx)(I.h2,{id:"interface",children:"Interface"}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set1(obj, globalNode, VALUE, storageFMT, scale, &\n    & addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: globalNode(:)\n    REAL(DFP), INTENT(IN) :: VALUE(:, :)\n    INTEGER(I4B), INTENT(IN) :: storageFMT\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set1\nEND INTERFACE\n"})}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set2(obj, globalNode, VALUE, scale, addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), OPTIONAL, INTENT(IN) :: globalNode(:)\n    REAL(DFP), INTENT(IN) :: VALUE\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set2\nEND INTERFACE\n"})}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set3(obj, iNodeNum, jNodeNum, idof, jdof, VALUE, &\n    & scale, addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: iNodeNum\n    INTEGER(I4B), INTENT(IN) :: jNodeNum\n    INTEGER(I4B), INTENT(IN) :: idof\n    INTEGER(I4B), INTENT(IN) :: jdof\n    REAL(DFP), INTENT(IN) :: VALUE\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set3\nEND INTERFACE\n"})}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set4(obj, iNodeNum, jNodeNum, ivar, jvar, VALUE, &\n    & scale, addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: iNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: jNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: jvar\n    REAL(DFP), INTENT(IN) :: VALUE(:, :)\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set4\nEND INTERFACE\n"})}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set5(obj, iNodeNum, jNodeNum, ivar, jvar, idof,  &\n    & jdof, VALUE, scale, addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: iNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: jNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: jvar\n    INTEGER(I4B), INTENT(IN) :: idof\n    INTEGER(I4B), INTENT(IN) :: jdof\n    REAL(DFP), INTENT(IN) :: VALUE(:, :)\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set5\nEND INTERFACE\n"})}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set6(obj, iNodeNum, jNodeNum, ivar, jvar, &\n    & idof, jdof, VALUE, scale, addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: iNodeNum\n    INTEGER(I4B), INTENT(IN) :: jNodeNum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: jvar\n    INTEGER(I4B), INTENT(IN) :: idof\n    INTEGER(I4B), INTENT(IN) :: jdof\n    REAL(DFP), INTENT(IN) :: VALUE\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set6\nEND INTERFACE\n"})}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set7(obj, iNodeNum, jNodeNum, ivar, jvar, &\n    & ispacecompo, itimecompo, jspacecompo, jtimecompo, &\n    & VALUE, scale, addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: iNodeNum\n    INTEGER(I4B), INTENT(IN) :: jNodeNum\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: jvar\n    INTEGER(I4B), INTENT(IN) :: ispacecompo\n    INTEGER(I4B), INTENT(IN) :: itimecompo\n    INTEGER(I4B), INTENT(IN) :: jspacecompo\n    INTEGER(I4B), INTENT(IN) :: jtimecompo\n    REAL(DFP), INTENT(IN) :: VALUE\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set7\nEND INTERFACE\n"})}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set8(obj, iNodeNum, jNodeNum, ivar, jvar, &\n    & ispacecompo, itimecompo, jspacecompo, jtimecompo, &\n    & VALUE, scale, addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: iNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: jNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: jvar\n    INTEGER(I4B), INTENT(IN) :: ispacecompo\n    INTEGER(I4B), INTENT(IN) :: itimecompo\n    INTEGER(I4B), INTENT(IN) :: jspacecompo\n    INTEGER(I4B), INTENT(IN) :: jtimecompo\n    REAL(DFP), INTENT(IN) :: VALUE\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set8\nEND INTERFACE\n"})}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set9(obj, iNodeNum, jNodeNum, ivar, jvar, &\n    & ispacecompo, itimecompo, jspacecompo, jtimecompo, &\n    & VALUE, scale, addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: iNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: jNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: jvar\n    INTEGER(I4B), INTENT(IN) :: ispacecompo\n    INTEGER(I4B), INTENT(IN) :: itimecompo(:)\n    INTEGER(I4B), INTENT(IN) :: jspacecompo\n    INTEGER(I4B), INTENT(IN) :: jtimecompo(:)\n    REAL(DFP), INTENT(IN) :: VALUE\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set9\nEND INTERFACE\n"})}),"\n",(0,n.jsx)(I.pre,{children:(0,n.jsx)(I.code,{className:"language-fortran",children:"INTERFACE\n  SUBROUTINE set10(obj, iNodeNum, jNodeNum, ivar, jvar, &\n    & ispacecompo, itimecompo, jspacecompo, jtimecompo, &\n    & VALUE, scale, addContribution)\n    IMPORT :: AbstractMatrixField_, I4B, DFP, LGT\n    CLASS(AbstractMatrixField_), INTENT(INOUT) :: obj\n    INTEGER(I4B), INTENT(IN) :: iNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: jNodeNum(:)\n    INTEGER(I4B), INTENT(IN) :: ivar\n    INTEGER(I4B), INTENT(IN) :: jvar\n    INTEGER(I4B), INTENT(IN) :: ispacecompo(:)\n    INTEGER(I4B), INTENT(IN) :: itimecompo\n    INTEGER(I4B), INTENT(IN) :: jspacecompo(:)\n    INTEGER(I4B), INTENT(IN) :: jtimecompo\n    REAL(DFP), INTENT(IN) :: VALUE\n    REAL(DFP), OPTIONAL, INTENT(IN) :: scale\n    LOGICAL(LGT), OPTIONAL, INTENT(IN) :: addContribution\n  END SUBROUTINE set10\nEND INTERFACE\n"})})]})}function d(N={}){const{wrapper:I}={...(0,E.a)(),...N.components};return I?(0,n.jsx)(I,{...N,children:(0,n.jsx)(r,{...N})}):r(N)}},11151:(N,I,T)=>{T.d(I,{Z:()=>o,a:()=>t});var n=T(67294);const E={},e=n.createContext(E);function t(N){const I=n.useContext(e);return n.useMemo((function(){return"function"==typeof N?N(I):{...I,...N}}),[I,N])}function o(N){let I;return I=N.disableParentContext?"function"==typeof N.components?N.components(E):N.components||E:t(N.components),n.createElement(e.Provider,{value:I},N.children)}}}]);