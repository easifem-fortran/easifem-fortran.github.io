"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[57923],{74573:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var t=i(85893),s=i(11151);const l={title:"Structure",sidebar_position:2},a=void 0,r={id:"Mesh/Mesh_",title:"Structure",description:"Mesh datatype is simply a collection of mesh elements.",source:"@site/docs/docs-api/Mesh/Mesh_.md",sourceDirName:"Mesh",slug:"/Mesh/Mesh_",permalink:"/docs-api/Mesh/Mesh_",draft:!1,unlisted:!1,editUrl:"https://github.com/easifem-fortran/easifem-fortran.github.io/tree/main/docs/docs-api/Mesh/Mesh_.md",tags:[],version:"current",lastUpdatedAt:1706190029,formattedLastUpdatedAt:"Jan 25, 2024",sidebarPosition:2,frontMatter:{title:"Structure",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Mesh",permalink:"/docs-api/Mesh/"},next:{title:"NodeData",permalink:"/docs-api/Mesh/NodeData_"}},o={},d=[];function c(e){const n={annotation:"annotation",code:"code",li:"li",math:"math",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Mesh datatype is simply a collection of mesh elements."}),"\n",(0,t.jsx)(n.p,{children:"In EASIFEM mesh is a homogeneous collection of reference elements. All elements in mesh should be of same type (i.e., triangle, quadrangle, tetrahedron, etc.). Two mesh can have different types of elements. For example, we can define a mesh of triangle element or a mesh of tetrahedron element."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-fortran",children:"TYPE :: Mesh_\n  PRIVATE\n  LOGICAL(LGT) :: readFromFile = .TRUE.\n    !! True if the mesh is read from a file\n  LOGICAL(LGT) :: isInitiated = .FALSE.\n    !! logical flag denoting for whether mesh data is Initiated or not\n  LOGICAL(LGT) :: isNodeToElementsInitiated = .FALSE.\n    !! Node to elements mapping\n  LOGICAL(LGT) :: isNodeToNodesInitiated = .FALSE.\n    !! Node to nodes mapping\n  LOGICAL(LGT) :: isExtraNodeToNodesInitiated = .FALSE.\n    !! Node to nodes mapping\n  LOGICAL(LGT) :: isElementToElementsInitiated = .FALSE.\n    !! Element to elements mapping\n  LOGICAL(LGT) :: isBoundaryDataInitiated = .FALSE.\n    !! Boundary data\n  LOGICAL(LGT), PUBLIC :: isFacetDataInitiated = .FALSE.\n    !! FacetData\n    !! TODO: Make isFacetDataInitiated PRIVATE\n  INTEGER(I4B) :: uid = 0\n    !! Unique id of the mesh\n  INTEGER(I4B) :: xidim = 0\n    !! xidimension of elements present inside the mesh\n  INTEGER(I4B) :: elemType = 0\n    !! type of element present inside the mesh\n  INTEGER(I4B) :: nsd = 0\n    !! number of spatial dimension of the mesh\n  INTEGER(I4B), PUBLIC :: maxNptrs = 0\n    !! largest node number present inside the mesh\n  INTEGER(I4B), PUBLIC :: minNptrs = 0\n    !! minimum node number present inside the mesh\n  INTEGER(I4B), PUBLIC :: maxElemNum = 0\n    !! largest element number present inside the mesh\n  INTEGER(I4B), PUBLIC :: minElemNum = 0\n    !! minimum element number present inside the mesh\n  INTEGER(I4B) :: tNodes = 0\n    !! total number of nodes present inside the mesh\n  INTEGER(I4B) :: tIntNodes = 0\n    !! total number of internal nodes inside the mesh\n  INTEGER(I4B) :: tElements = 0\n    !! total number of elements present inside the mesh\n    !! It is the size of elemNumber vector\n  REAL(DFP) :: minX = 0.0\n    !! minimum value of x coordinate\n  REAL(DFP) :: maxX = 0.0\n    !! maximum value of x coordinate\n  REAL(DFP) :: minY = 0.0\n    !! minimum value of y coordinate\n  REAL(DFP) :: maxY = 0.0\n    !! maximum value of y coordinate\n  REAL(DFP) :: minZ = 0.0\n    !! minimum value of z coordinate\n  REAL(DFP) :: maxZ = 0.0\n    !! maximum value of z coordinate\n  REAL(DFP) :: X = 0.0\n    !! x coorindate of centroid\n  REAL(DFP) :: Y = 0.0\n    !! y coordinate of centroid\n  REAL(DFP) :: Z = 0.0\n    !! z coordinate of centroid\n  INTEGER(I4B), ALLOCATABLE :: physicalTag(:)\n    !! Physical entities associated with the current entity (mesh)\n  INTEGER(I4B), ALLOCATABLE :: boundingEntity(:)\n    !! Bounding entity numbers of the current entity\n  INTEGER(I4B), ALLOCATABLE :: local_elemNumber(:)\n    !! List of local element numbers, the lowerbound is `minElemNum`\n    !! and upper bound is `maxElemNum`. In this way, local_elemNumber(iel)\n    !! returns the local element number of global element number iel.\n  INTEGER(I4B), ALLOCATABLE :: local_Nptrs(:)\n    !! Returns local node number from a global node number\n    !! Its length is from 1 to maxNptrs\n    !! Helpul in finding if a global node is present inside the mesh or not\n  INTEGER(I4B), ALLOCATABLE :: material(:)\n    !! materials mapped to the mesh\n    !! material(1) is the material id of medium 1\n    !! material(2) is the material id of medium 2\n    !! ...\n    !! material(n) is the material id of medium n\n    !!\n    !! For example, soil is a porous medium n = 1,\n    !! fluid is a medium n =2\n    !! then material(1) denotes the type of soil => clay, sand, silt\n    !! and material(2) denotes the type of fluid, water, oil, air\n  TYPE(ReferenceElement_), PUBLIC, ALLOCATABLE :: facetElements(:)\n    !! Facet Elements in the reference element\n  INTEGER(I4B), ALLOCATABLE :: facetElementType(:, :)\n  !! Number of rows of this array is same as the total number of\n  !! facets present in the mesh-reference elements\n  !! Number of columns of this array is equal to the total number of\n  !! elements inside the mesh\n  !! facetElementType(ii, iel) can be\n  !! INTERNAL_ELEMENT, BOUNDARY_ELEMENT, DOMAIN_BOUNDARY_ELEMENT\n  !! If the face is a part of the mesh boundary then it will be called\n  !! the BOUNDARY_ELEMENT\n  TYPE(NodeData_), ALLOCATABLE :: nodeData(:)\n    !! Node data\n  TYPE(ElemData_), ALLOCATABLE :: elementData(:)\n    !! element data\n  TYPE(InternalFacetData_), PUBLIC, ALLOCATABLE :: internalFacetData(:)\n    !! Internal facet data\n  TYPE(BoundaryFacetData_), PUBLIC, ALLOCATABLE :: boundaryFacetData(:)\n    !! Domain Facet Data\n  CLASS(ReferenceElement_), PUBLIC, POINTER :: refelem => NULL()\n    !! Reference element of the mesh (spatial)\n    !! TODO: Change refelem to Type(ReferenceElement_)\n  REAL(DFP), ALLOCATABLE :: quality(:, :)\n    !! number of rows are meshquality\n    !! number of columns are elements\n  INTEGER(I4B), PUBLIC :: ipType = Equidistance\n    !! interpolation point type\n\n  ! Following variables are required during processing.\n  ! time\n  TYPE(QuadraturePoint_), PUBLIC :: quadForTime\n    !! quadrature point for time domain #STFEM\n  TYPE(ElemshapeData_), PUBLIC :: linTimeElemSD\n    !! Element shape data on linear time element #STFEM\n  TYPE(ElemshapeData_), PUBLIC :: timeElemSD\n    !! Element shape data on time element #STFEM\n  TYPE(String) :: quadTypeForTime\n    !! quadrature type for time\n  TYPE(String) :: continuityTypeForTime\n    !! continuity of base function for time\n  TYPE(String) :: interpolTypeForTime\n    !! interpolation of base function for time\n  INTEGER(I4B) :: orderTime\n    !! order for time\n\n  ! space (cell)\n  TYPE(QuadraturePoint_), PUBLIC :: quadForSpace\n    !! quadrature point for space\n  TYPE(ElemshapeData_), PUBLIC :: linSpaceElemSD\n    !! Element shape data on linear space (simplex) element\n  TYPE(ElemshapeData_), PUBLIC :: spaceElemSD\n    !! Element shape data on space element\n  TYPE(STElemshapeData_), ALLOCATABLE, PUBLIC :: stelemsd(:)\n    !! Element shape data on space element\n  TYPE(String) :: quadTypeForSpace\n    !! quadrature type for space\n  TYPE(String) :: continuityTypeForSpace\n    !! continuity of base function for space\n  TYPE(String) :: interpolTypeForSpace\n    !! interoplation type of base function for space\n  INTEGER(I4B) :: orderSpace\n    !! order for space\n\n  ! space (facets)\n  TYPE(QuadraturePoint_), ALLOCATABLE, PUBLIC :: quadForFacet(:)\n    !! quadrature point for facet elements\n  TYPE(QuadraturePoint_), ALLOCATABLE, PUBLIC :: quadForFacetCell(:)\n    !! quadrature point for facet-cell elements\n  TYPE(ElemshapeData_), ALLOCATABLE, PUBLIC :: linFacetElemSD(:)\n    !! Element shape data on linear facet (simplex) element\n  TYPE(ElemshapeData_), ALLOCATABLE, PUBLIC :: linFacetCellElemSD(:)\n    !! Element shape data on linear facet (simplex) cell element\n  TYPE(ElemshapeData_), ALLOCATABLE, PUBLIC :: facetElemSD(:)\n    !! Element shape data on facet element\n  TYPE(ElemshapeData_), ALLOCATABLE, PUBLIC :: facetCellElemSD(:)\n    !! Element shape data on facet cell element\n  TYPE(String) :: quadTypeForFacet\n    !! quadrature type for facet element\n  TYPE(String) :: continuityTypeForFacet\n    !! continuity of base function for facet element\n  TYPE(String) :: interpolTypeForFacet\n    !! interoplation type of base function for facet element\n  INTEGER(I4B) :: orderFacet\n    !! order for facet element\n  TYPE(STElemshapeData_), ALLOCATABLE, PUBLIC :: facetSTelemsd(:, :)\n    !! Element shape data on facet element\nEND TYPE Mesh_\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"readFromFile"})," is true if the mesh is read from a file."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"isInitiated"})," is logical flag denoting whether mesh data is initiated or not."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"isNodeToElementsInitiated"})," is true if node to elements mapping is initiated."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"isNodeToNodesInitiated"})," is true of node to nodes mapping is initiated."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"isElementToElementsInitiated"})," is true if element to elements mapping available."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"isBoundaryDataInitiated"})," is true if boundary data is available."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"uid"})," denotes the unique-id of the mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"xidim"})," denotes the ",(0,t.jsx)(n.code,{children:"xidimension"})," of elements present inside the mesh, ",(0,t.jsx)(n.code,{children:"xidim"})," = (0,1,2,3) for (point, line, surface, volume) elements."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"elemType"})," denotes the type of element present inside the mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"nsd"})," denotes the number of spatial dimension of the mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"maxNptrs"})," stands for the largest node number present inside the mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"minNptrs"})," stands for the smallest node number present inside the mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"maxElemNum"})," denotes the largest element number present inside the mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"minElemNum"})," denotes the smallest element number present inside the mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"tNodes"})," is the total number of (local) nodes present inside the mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"tIntNodes"})," is the total number of internal nodes inside the mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"tElements"})," is the total number of elements present inside the mesh. It is the size of ",(0,t.jsx)(n.code,{children:"elemNumber"})," vector."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"minX"})," denotes the minimum value of x coordinate of ",(0,t.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"maxX"})," denotes the maximum value of x coordinate of ",(0,t.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"minY"})," is the minimum value of y coordinate of ",(0,t.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"maxY"})," is the maximum value of y coordinate of ",(0,t.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"minZ"})," is the minimum value of z coordinate of ",(0,t.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"maxZ"})," is the maximum value of z coordinate of ",(0,t.jsx)(n.code,{children:"boundingbox"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"X"})," is the x coordinate of center of mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Y"})," is the y coordinate of center of mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Z"})," is the z coordinate of center of mesh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"physicalTag"})," denotes the physical entities associated with the current entity (mesh)"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"boundingEntity"})," denotes the bounding entity numbers of the current entity"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"local_elemNumber"})," denotes the list of local element numbers, the lower bound is ",(0,t.jsx)(n.code,{children:"minElemNum"})," and upper bound is ",(0,t.jsx)(n.code,{children:"maxElemNum"}),". In this way, ",(0,t.jsx)(n.code,{children:"local_elemNumber(iel)"})," returns the local element number of global element number ",(0,t.jsx)(n.code,{children:"iel"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"local_Nptrs"})," returns the local node number from a global node number. Its length is from 1 to ",(0,t.jsx)(n.code,{children:"maxNptrs"}),". Helpful in finding if a global node is present inside the mesh or not."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"material"})," materials mapped to the mesh, for example"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"material(1)"})," is the material-id of medium 1"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"material(2)"})," is the material-id of medium 2"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mo,{children:"\u22ef"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\cdots"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.313em"}}),(0,t.jsx)(n.span,{className:"minner",children:"\u22ef"})]})})]})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"material(n)"})," is the material-id of medium n"]}),"\n",(0,t.jsx)(n.li,{children:"For example, soil is a porous medium n = 1,"}),"\n",(0,t.jsx)(n.li,{children:"fluid is a medium n =2"}),"\n",(0,t.jsx)(n.li,{children:"then material(1) denotes the type of soil, that is, clay, sand, and silt."}),"\n",(0,t.jsx)(n.li,{children:"and material(2) denotes the type of fluid, water, oil, air."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"facetElements"})," denotes the facet Elements in the reference element"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"facetElementType"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Number of rows of this array is same as the total number of facets present in the mesh\u2019s reference-element."}),"\n",(0,t.jsx)(n.li,{children:"Number of columns of this array is equal to the total number of elements inside the mesh."}),"\n",(0,t.jsxs)(n.li,{children:["In this way, ",(0,t.jsx)(n.code,{children:"facetElementType(ii, iel)"})," denotes the ",(0,t.jsx)(n.code,{children:"ii"}),"th facet\u2019s type of element local element number ",(0,t.jsx)(n.code,{children:"iel"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"facetElementType"})," can be","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"INTERNAL_ELEMENT"}),","]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"BOUNDARY_ELEMENT"}),","]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DOMAIN_BOUNDARY_ELEMENT"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["If the face is a part of the mesh boundary then it will be called the ",(0,t.jsx)(n.code,{children:"BOUNDARY_ELEMENT"})]}),"\n",(0,t.jsxs)(n.li,{children:["If the face is part of domain boundary, then it is a ",(0,t.jsx)(n.code,{children:"DOMAIN_BOUNDARY_ELEMENT"})]}),"\n",(0,t.jsxs)(n.li,{children:["If the facet is internal to a mesh, then it is a ",(0,t.jsx)(n.code,{children:"INTERNAL_ELEMENT"})]}),"\n",(0,t.jsxs)(n.li,{children:["Note that every, ",(0,t.jsx)(n.code,{children:"DOMAIN_BOUNDARY_ELEMENT"})," is ",(0,t.jsx)(n.code,{children:"BOUNDARY_ELEMENT"})," but not vice-versa."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"nodeData"})," node data"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"elementData"})," element data"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"internalFacetData"})," internal facet data"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"boundaryFacetData"})," boundary facet Data"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"refelem"})," Reference element of the mesh (spatial)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Following variables are required during for time shape functions in space-time finite elements."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"quadForTime"}),", quadrature point for time domain"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"linTimeElemSD"})," Element shape data on linear time element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"timeElemSD"})," Element shape data on time element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"quadTypeForTime"})," quadrature type for time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"continuityTypeForTime"})," continuity of base function for time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"interpolTypeForTime"})," interpolation of base function for time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"orderTime"})," order for time"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Following variables are required during for space-shape functions finite elements computations."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"quadForSpace"})," quadrature point for space"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"linSpaceElemSD"})," Element shape data on linear space (simplex) element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"spaceElemSD"})," Element shape data on space element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"stelemsd"})," Element shape data on space element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"quadTypeForSpace"})," quadrature type for space"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"continuityTypeForSpace"})," continuity of base function for space"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"interpolTypeForSpace"})," interpolation type of base function for space"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"orderSpace"})," order for space"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Following variables are required during for shape functions on facet elements in finite elements computations."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"quadForFacet"})," quadrature point for facet elements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"linFacetElemSD"})," Element shape data on linear facet (simplex) element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"facetElemSD"})," Element shape data on facet element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"facetSTelemsd"})," Element shape data on facet element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"quadTypeForFacet"})," quadrature type for facet element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"continuityTypeForFacet"})," continuity of base function for facet element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"interpolTypeForFacet"})," interpolation type of base function for facet element"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"orderFacet"})," order for facet element"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>r,a:()=>a});var t=i(67294);const s={},l=t.createContext(s);function a(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);