"use strict";(self.webpackChunkeasifem_docs=self.webpackChunkeasifem_docs||[]).push([[4608],{60542:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var a=e(85893),c=e(11151);const s={},i="AbstractBC",r={id:"AbstractBC/AbstractBC_",title:"AbstractBC",description:"Abstract classs for handling boundary conditions in finite element methods.",source:"@site/docs/docs-api/AbstractBC/AbstractBC_.md",sourceDirName:"AbstractBC",slug:"/AbstractBC/AbstractBC_",permalink:"/docs-api/AbstractBC/AbstractBC_",draft:!1,unlisted:!1,editUrl:"https://github.com/vickysharma0812/vickysharma0812.github.io/tree/main/docs/docs-api/AbstractBC/AbstractBC_.md",tags:[],version:"current",lastUpdatedAt:1701057211,formattedLastUpdatedAt:"Nov 27, 2023",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AbstractBC",permalink:"/docs-api/AbstractBC/"},next:{title:"CheckEssentialParam",permalink:"/docs-api/AbstractBC/CheckEssentialParam"}},o={},d=[{value:"Structure",id:"structure",level:2}];function u(t){const n={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,c.a)(),...t.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"abstractbc",children:"AbstractBC"}),"\n",(0,a.jsx)(n.p,{children:"Abstract classs for handling boundary conditions in finite element methods."}),"\n",(0,a.jsx)(n.h2,{id:"structure",children:"Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-fortran",children:"TYPE, ABSTRACT :: AbstractBC_\n  LOGICAL(LGT) :: isInitiated = .FALSE.\n  TYPE(String) :: name\n  INTEGER(I4B) :: idof = 0\n  INTEGER(I4B) :: nodalValueType = -1\n    !! Constant, Space, Time, SpaceTime\n  LOGICAL(LGT) :: useFunction = .FALSE.\n    !! True if the boundary condition is analytical\n  REAL(DFP), ALLOCATABLE :: nodalValue(:, :)\n    !! nodal values are kept here,\n    !! nodalValues( :, its ) denotes nodal values at\n    !! time step its\n  PROCEDURE(iface_SpaceTimeFunction), POINTER, NOPASS :: &\n    & SpaceTimeFunction => NULL()\n    !! SpaceTime Functions\n  PROCEDURE(iface_SpaceFunction), POINTER, NOPASS :: &\n    & SpaceFunction => NULL()\n    !! Space Function\n  PROCEDURE(iface_TimeFunction), POINTER, NOPASS :: &\n    & TimeFunction => NULL()\n    !! Time Function\n  TYPE(MeshSelection_) :: boundary\n    !! Boundary\n  CLASS(Domain_), POINTER :: dom => NULL()\n    !! Domain\n"})})]})}function l(t={}){const{wrapper:n}={...(0,c.a)(),...t.components};return n?(0,a.jsx)(n,{...t,children:(0,a.jsx)(u,{...t})}):u(t)}},11151:(t,n,e)=>{e.d(n,{Z:()=>r,a:()=>i});var a=e(67294);const c={},s=a.createContext(c);function i(t){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function r(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(c):t.components||c:i(t.components),a.createElement(s.Provider,{value:n},t.children)}}}]);